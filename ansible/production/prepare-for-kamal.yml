---
# This playbook prepares the server infrastructure (Docker, security, networking)
# After running this playbook, perform FIRST deployment with:
#   kamal setup -d production
# Then run this playbook again to configure PostgreSQL roles:
#   ansible-playbook ansible/production/prepare-for-kamal.yml -i ansible/inventory/production.ini --tags postgres-roles
# Subsequent deployments use:
#   kamal deploy -d production

- name: Prepare Production VPS for Kamal Deployment
  hosts: production_vps
  
  vars_files:
    - vars/bitwarden_refs.yml
  
  vars:
    postgres_container: "kw-app-postgres"
    postgres_user: "production_user"
  
  tasks:
    - name: Verify Bitwarden Secrets Manager CLI is available
      delegate_to: localhost
      command: which bws
      register: bws_check
      failed_when: bws_check.rc != 0
      changed_when: false
      
    - name: Verify BWS_ACCESS_TOKEN is set
      delegate_to: localhost
      shell: echo $BWS_ACCESS_TOKEN
      register: bws_token_check
      failed_when: bws_token_check.stdout == ""
      changed_when: false
      
    - name: Fetch sudo password from Bitwarden Secrets Manager
      delegate_to: localhost
      shell: bws secret get "{{ bws_vps_sudo_uuid }}" --access-token "$BWS_ACCESS_TOKEN" | jq -r '.value'
      environment:
        BWS_ACCESS_TOKEN: "{{ lookup('env', 'BWS_ACCESS_TOKEN') }}"
      register: sudo_password_raw
      no_log: true
      changed_when: false
    
    - name: Set sudo password
      set_fact:
        ansible_become_pass: "{{ sudo_password_raw.stdout }}"
      no_log: true
    
    # ============================================
    # PHASE 1: SYSTEM UPDATE
    # ============================================
    
    - name: Update apt cache
      become: yes
      apt:
        update_cache: yes
        cache_valid_time: 3600
    
    - name: Upgrade all packages
      become: yes
      apt:
        upgrade: dist
        update_cache: yes
      register: apt_upgrade
      
    - name: Check if reboot required
      become: yes
      stat:
        path: /var/run/reboot-required
      register: reboot_required_file
    
    - name: Display reboot notice
      debug:
        msg: "⚠️  Server reboot required after upgrade. Will be handled at end of playbook."
      when: reboot_required_file.stat.exists
    
    # ============================================
    # PHASE 2: SECURITY HARDENING
    # ============================================
    
    - name: Install security packages
      become: yes
      apt:
        name:
          - ufw
          - fail2ban
          - unattended-upgrades
        state: present
    
    # UFW Firewall Configuration
    - name: Reset UFW to default state
      become: yes
      ufw:
        state: reset
      
    - name: Set UFW default policy (deny incoming)
      become: yes
      ufw:
        direction: incoming
        policy: deny
    
    - name: Set UFW default policy (allow outgoing)
      become: yes
      ufw:
        direction: outgoing
        policy: allow
    
    - name: Allow SSH (port 22)
      become: yes
      ufw:
        rule: allow
        port: '22'
        proto: tcp
        comment: 'SSH access'
    
    - name: Allow HTTP (port 80)
      become: yes
      ufw:
        rule: allow
        port: '80'
        proto: tcp
        comment: 'HTTP for Let Encrypt and Cloudflare'
    
    - name: Allow HTTPS (port 443)
      become: yes
      ufw:
        rule: allow
        port: '443'
        proto: tcp
        comment: 'HTTPS traffic'
    
    - name: Enable UFW
      become: yes
      ufw:
        state: enabled
    
    - name: Display firewall status
      become: yes
      command: ufw status verbose
      register: ufw_status
      changed_when: false
      
    - name: Show UFW configuration
      debug:
        msg: "{{ ufw_status.stdout_lines }}"
    
    # SSH Hardening
    - name: Disable password authentication for SSH
      become: yes
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PasswordAuthentication'
        line: 'PasswordAuthentication no'
        state: present
      notify: restart ssh
    
    - name: Disable root login via SSH
      become: yes
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PermitRootLogin'
        line: 'PermitRootLogin no'
        state: present
      notify: restart ssh
    
    - name: Disable empty passwords
      become: yes
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PermitEmptyPasswords'
        line: 'PermitEmptyPasswords no'
        state: present
      notify: restart ssh
    
    - name: Enable SSH key-based authentication
      become: yes
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: '^#?PubkeyAuthentication'
        line: 'PubkeyAuthentication yes'
        state: present
      notify: restart ssh
    
    # Fail2ban Configuration
    - name: Enable and start fail2ban
      become: yes
      systemd:
        name: fail2ban
        enabled: yes
        state: started
    
    - name: Configure fail2ban for SSH
      become: yes
      copy:
        content: |
          [sshd]
          enabled = true
          port = 22
          filter = sshd
          logpath = /var/log/auth.log
          maxretry = 5
          bantime = 3600
          findtime = 600
        dest: /etc/fail2ban/jail.d/sshd.conf
        mode: '0644'
      notify: restart fail2ban
    
    # Unattended Upgrades Configuration
    - name: Configure automatic security updates
      become: yes
      copy:
        content: |
          APT::Periodic::Update-Package-Lists "1";
          APT::Periodic::Download-Upgradeable-Packages "1";
          APT::Periodic::Unattended-Upgrade "1";
          APT::Periodic::AutocleanInterval "7";
        dest: /etc/apt/apt.conf.d/20auto-upgrades
        mode: '0644'
    
    - name: Configure unattended-upgrades to auto-reboot if needed
      become: yes
      lineinfile:
        path: /etc/apt/apt.conf.d/50unattended-upgrades
        regexp: '^//Unattended-Upgrade::Automatic-Reboot '
        line: 'Unattended-Upgrade::Automatic-Reboot "false";'
        state: present
    
    # Swap File Configuration
    - name: Check if swap file exists
      become: yes
      stat:
        path: /swapfile
      register: swap_file
    
    - name: Check current swap
      command: swapon --show
      register: current_swap
      changed_when: false
    
    - name: Create 2GB swap file
      become: yes
      command: fallocate -l 2G /swapfile
      when: not swap_file.stat.exists
    
    - name: Set swap file permissions
      become: yes
      file:
        path: /swapfile
        mode: '0600'
        owner: root
        group: root
      when: not swap_file.stat.exists
    
    - name: Format swap file
      become: yes
      command: mkswap /swapfile
      when: not swap_file.stat.exists
    
    - name: Enable swap file
      become: yes
      command: swapon /swapfile
      when: not swap_file.stat.exists
    
    - name: Add swap to fstab for persistence
      become: yes
      lineinfile:
        path: /etc/fstab
        regexp: '^/swapfile'
        line: '/swapfile none swap sw 0 0'
        state: present
    
    - name: Set swappiness to 10 (prefer RAM)
      become: yes
      sysctl:
        name: vm.swappiness
        value: '10'
        state: present
        sysctl_set: yes
        reload: yes
    
    # Timezone Configuration
    - name: Set timezone to Europe/Warsaw
      become: yes
      timezone:
        name: Europe/Warsaw
    
    # ============================================
    # PHASE 3: DOCKER INSTALLATION
    # ============================================
    
    - name: Install Docker dependencies
      become: yes
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
          - python3-pip
          - python3-docker
        state: present
    
    - name: Install Docker
      become: yes
      apt:
        name: docker.io
        state: present
    
    - name: Verify Docker Python module is available
      become: yes
      command: python3 -c "import docker"
      register: docker_python_check
      changed_when: false
    
    - name: Add ubuntu user to docker group
      become: yes
      user:
        name: "{{ production_user }}"
        groups: docker
        append: yes
    
    - name: Enable and start Docker service
      become: yes
      systemd:
        name: docker
        enabled: yes
        state: started
    
    - name: Create Docker daemon configuration
      become: yes
      copy:
        content: |
          {
            "log-driver": "json-file",
            "log-opts": {
              "max-size": "10m",
              "max-file": "3"
            },
            "live-restore": true
          }
        dest: /etc/docker/daemon.json
        mode: '0644'
      notify: restart docker
    
    # ============================================
    # PHASE 4: KAMAL PREPARATION
    # ============================================
    
    - name: Reset SSH connection to apply docker group
      meta: reset_connection
    
    - name: Create kamal directory
      become: yes
      become_user: "{{ production_user }}"
      file:
        path: /home/{{ production_user }}/.kamal
        state: directory
        mode: '0755'
    
    - name: Create tmp directory for kamal clones
      become: yes
      file:
        path: /tmp/kamal-clones
        state: directory
        mode: '0755'
    
    - name: Clean old kamal clone directories
      become: yes
      shell: find /tmp/kamal-clones -type d -mtime +1 -exec rm -rf {} + 2>/dev/null || true
      changed_when: false
    
    - name: Create Docker network for Kamal
      become: yes
      docker_network:
        name: "{{ docker_network }}"
        state: present
    
    - name: Check if kamal-proxy is running
      become: yes
      docker_container_info:
        name: kamal-proxy
      register: kamal_proxy_info
      ignore_errors: yes
    
    - name: Pull kamal-proxy image if not present
      become: yes
      docker_image:
        name: basecamp/kamal-proxy
        tag: latest
        source: pull
      when: kamal_proxy_info.exists is not defined or not kamal_proxy_info.exists
    
    # ============================================
    # PHASE 6: DOCKER REGISTRY LOGIN
    # ============================================
    
    - name: Fetch Docker registry username from Bitwarden Secrets Manager
      delegate_to: localhost
      shell: bws secret get "{{ bws_registry_username_uuid }}" --access-token "$BWS_ACCESS_TOKEN" | jq -r '.value'
      environment:
        BWS_ACCESS_TOKEN: "{{ lookup('env', 'BWS_ACCESS_TOKEN') }}"
      register: docker_registry_username_raw
      no_log: true
      changed_when: false
      failed_when: docker_registry_username_raw.rc != 0
      
    - name: Fetch Docker registry password from Bitwarden Secrets Manager
      delegate_to: localhost
      shell: bws secret get "{{ bws_registry_password_uuid }}" --access-token "$BWS_ACCESS_TOKEN" | jq -r '.value'
      environment:
        BWS_ACCESS_TOKEN: "{{ lookup('env', 'BWS_ACCESS_TOKEN') }}"
      register: docker_registry_password_raw
      no_log: true
      changed_when: false
      failed_when: docker_registry_password_raw.rc != 0
      
    - name: Set Docker registry credentials
      set_fact:
        docker_registry_username: "{{ docker_registry_username_raw.stdout }}"
        docker_registry_password: "{{ docker_registry_password_raw.stdout }}"
      no_log: true
    
    - name: Verify credentials were fetched
      assert:
        that:
          - docker_registry_username != ""
          - docker_registry_password != ""
        fail_msg: "Failed to fetch Docker registry credentials from Bitwarden"
    
    - name: Create .docker directory
      become: yes
      become_user: "{{ production_user }}"
      file:
        path: /home/{{ production_user }}/.docker
        state: directory
        mode: '0700'
    
    - name: Login to Docker Hub
      shell: |
        echo "{{ docker_registry_password }}" | docker login -u "{{ docker_registry_username }}" --password-stdin
      args:
        executable: /bin/bash
      no_log: true
      register: docker_login_result
      failed_when: docker_login_result.rc != 0
    
    - name: Verify Docker login succeeded
      debug:
        msg: "✅ Docker Hub login successful"
      when: docker_login_result.rc == 0
    
    # ============================================
    # FINAL STATUS
    # ============================================
    
    - name: Display preparation status
      debug:
        msg:
          - "✅ Production server preparation complete!"
          - ""
          - "SECURITY:"
          - "   - UFW firewall enabled (ports 22, 80, 443)"
          - "   - SSH password auth disabled (keys only)"
          - "   - Root login disabled"
          - "   - Fail2ban active (SSH protection)"
          - "   - Automatic security updates enabled"
          - "   - 2GB swap file created"
          - "   - Timezone: Europe/Warsaw"
          - ""
          - "DOCKER & KAMAL:"
          - "   - Docker installed and running"
          - "   - User '{{ production_user }}' added to docker group"
          - "   - Docker Hub login configured"
          - "   - Kamal directories created"
          - "   - Docker network '{{ docker_network }}' created"
          - "   - kamal-proxy image pulled"
          - ""
          - "Server ready for Kamal deployment!"
    
    - name: Check if reboot is required
      become: yes
      stat:
        path: /var/run/reboot-required
      register: reboot_check
    
    - name: Notify if reboot needed
      debug:
        msg: "⚠️  REBOOT REQUIRED - Run 'ssh ubuntu@{{ production_host }} sudo reboot' after this playbook completes"
      when: reboot_check.stat.exists
    
    # ============================================
    # PHASE 6: POSTGRESQL ROLE CONFIGURATION
    # (Run after kamal accessory boot postgres)
    # ============================================
    
    - name: Check if PostgreSQL container exists
      become: yes
      docker_container_info:
        name: "{{ postgres_container }}"
      register: postgres_info
      ignore_errors: yes
      tags: [postgres-roles]
    
    - name: Skip PostgreSQL role setup if container not running
      debug:
        msg: "ℹ️  PostgreSQL container not running yet. Run 'kamal accessory boot postgres -d production' first, then re-run this playbook with --tags postgres-roles"
      when: postgres_info.exists is not defined or not postgres_info.exists or postgres_info.container.State.Status != 'running'
      tags: [postgres-roles]
    
    - name: Check if deploy role already exists
      become: yes
      command: >
        docker exec {{ postgres_container }}
        psql -U {{ postgres_user }} -d postgres
        -tAc "SELECT 1 FROM pg_roles WHERE rolname='deploy'"
      register: deploy_role_check
      changed_when: false
      failed_when: false
      when: postgres_info.exists is defined and postgres_info.exists and postgres_info.container.State.Status == 'running'
      tags: [postgres-roles]
    
    - name: Set deploy role exists fact
      set_fact:
        deploy_role_exists: "{{ deploy_role_check.stdout == '1' }}"
      when: deploy_role_check is not skipped
      tags: [postgres-roles]
    
    - name: Create deploy role for migration compatibility
      become: yes
      command: >
        docker exec {{ postgres_container }}
        psql -U {{ postgres_user }} -d postgres
        -c "CREATE ROLE deploy LOGIN;"
      when: 
        - postgres_info.exists is defined
        - postgres_info.exists
        - postgres_info.container.State.Status == 'running'
        - deploy_role_check is not skipped
        - deploy_role_check.stdout != '1'
      register: create_deploy_role
      tags: [postgres-roles]
    
    - name: Grant production_user privileges to deploy role
      become: yes
      command: >
        docker exec {{ postgres_container }}
        psql -U {{ postgres_user }} -d postgres
        -c "GRANT production_user TO deploy;"
      when: 
        - postgres_info.exists is defined
        - postgres_info.exists
        - postgres_info.container.State.Status == 'running'
        - deploy_role_check is not skipped
        - deploy_role_check.stdout != '1'
      register: grant_deploy_role
      tags: [postgres-roles]
    
    - name: Display PostgreSQL role configuration status
      debug:
        msg:
          - "✅ PostgreSQL deploy role configured successfully!"
          - ""
          - "PURPOSE:"
          - "   The 'deploy' role ensures database dumps from old production"
          - "   (which used 'deploy' user) can be restored without ownership errors."
          - "   This prevents 'ERROR: role deploy does not exist' during migration."
          - ""
          - "MIGRATION READY:"
          - "   You can now run: bin/migrate-database-to-new-prod --force"
      when: 
        - postgres_info.exists is defined
        - postgres_info.exists
        - create_deploy_role is changed
      tags: [postgres-roles]
    
    - name: Display deploy role already exists message
      debug:
        msg: "ℹ️  Deploy role already exists, no action needed"
      when: 
        - postgres_info.exists is defined
        - postgres_info.exists
        - deploy_role_check is not skipped
        - deploy_role_check.stdout == '1'
      tags: [postgres-roles]
  
  # ============================================
  # HANDLERS
  # ============================================
  
  handlers:
    - name: restart ssh
      become: yes
      systemd:
        name: ssh
        state: restarted
    
    - name: restart fail2ban
      become: yes
      systemd:
        name: fail2ban
        state: restarted
    
    - name: restart docker
      become: yes
      systemd:
        name: docker
        state: restarted