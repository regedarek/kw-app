name: Deploy Production
concurrency:
  group: production
  cancel-in-progress: false

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      DOCKER_BUILDKIT: 1

    steps:
      - uses: actions/checkout@v4
      
      # Install Bitwarden Secrets Manager CLI
      - name: Install Bitwarden Secrets Manager CLI
        run: |
          if ! command -v bws &> /dev/null; then
            echo "Installing Bitwarden Secrets Manager CLI v1.0.0..."
            
            # Download x86_64 binary for v1.0.0 (GitHub hosted runners are x86_64)
            curl -L -o bws-x86_64-unknown-linux-gnu.zip \
              "https://github.com/bitwarden/sdk-sm/releases/download/bws-v1.0.0/bws-x86_64-unknown-linux-gnu-1.0.0.zip"
            
            unzip -o bws-x86_64-unknown-linux-gnu.zip
            chmod +x bws
            sudo mv bws /usr/local/bin/
            rm bws-x86_64-unknown-linux-gnu.zip
          else
            echo "✅ Bitwarden Secrets Manager CLI already installed"
          fi
          
          bws --version
      
      # Fetch secrets from Bitwarden Secrets Manager
      - name: Get Secrets from Bitwarden
        env:
          BWS_ACCESS_TOKEN: ${{ secrets.BW_ACCESS_TOKEN_PRODUCTION }}
        run: |
          echo "Fetching secrets from Bitwarden Secrets Manager..."
          
          # Install jq for JSON parsing
          sudo apt-get update -qq
          sudo apt-get install -y jq
          
          # Fetch each secret by ID and export as environment variable
          export KAMAL_REGISTRY_USERNAME=$(bws secret get ${{ secrets.BW_SECRET_REGISTRY_USERNAME }} --access-token "$BWS_ACCESS_TOKEN" | jq -r '.value')
          export KAMAL_REGISTRY_PASSWORD=$(bws secret get ${{ secrets.BW_SECRET_REGISTRY_PASSWORD }} --access-token "$BWS_ACCESS_TOKEN" | jq -r '.value')
          export RAILS_MASTER_KEY=$(bws secret get ${{ secrets.BW_SECRET_PRODUCTION_MASTER_KEY }} --access-token "$BWS_ACCESS_TOKEN" | jq -r '.value')
          export POSTGRES_PASSWORD=$(bws secret get ${{ secrets.BW_SECRET_PRODUCTION_POSTGRES_PASSWORD }} --access-token "$BWS_ACCESS_TOKEN" | jq -r '.value')
          export REDIS_PASSWORD=$(bws secret get ${{ secrets.BW_SECRET_PRODUCTION_REDIS_PASSWORD }} --access-token "$BWS_ACCESS_TOKEN" | jq -r '.value')
          
          # Save to GITHUB_ENV for subsequent steps
          echo "KAMAL_REGISTRY_USERNAME=$KAMAL_REGISTRY_USERNAME" >> $GITHUB_ENV
          echo "KAMAL_REGISTRY_PASSWORD=$KAMAL_REGISTRY_PASSWORD" >> $GITHUB_ENV
          echo "RAILS_MASTER_KEY=$RAILS_MASTER_KEY" >> $GITHUB_ENV
          echo "POSTGRES_PASSWORD=$POSTGRES_PASSWORD" >> $GITHUB_ENV
          echo "REDIS_PASSWORD=$REDIS_PASSWORD" >> $GITHUB_ENV
          
          # Verify secrets are set (without exposing values)
          [[ -n "$KAMAL_REGISTRY_USERNAME" ]] && echo "✅ KAMAL_REGISTRY_USERNAME fetched" || { echo "❌ KAMAL_REGISTRY_USERNAME missing"; exit 1; }
          [[ -n "$KAMAL_REGISTRY_PASSWORD" ]] && echo "✅ KAMAL_REGISTRY_PASSWORD fetched" || { echo "❌ KAMAL_REGISTRY_PASSWORD missing"; exit 1; }
          [[ -n "$RAILS_MASTER_KEY" ]] && echo "✅ RAILS_MASTER_KEY fetched (length: ${#RAILS_MASTER_KEY})" || { echo "❌ RAILS_MASTER_KEY missing"; exit 1; }
          [[ -n "$POSTGRES_PASSWORD" ]] && echo "✅ POSTGRES_PASSWORD fetched" || { echo "❌ POSTGRES_PASSWORD missing"; exit 1; }
          [[ -n "$REDIS_PASSWORD" ]] && echo "✅ REDIS_PASSWORD fetched" || { echo "❌ REDIS_PASSWORD missing"; exit 1; }
          
          echo ""
          echo "✅ All secrets fetched successfully from Bitwarden Secrets Manager!"
      
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2.2'
          bundler-cache: false
      
      - name: Install Kamal
        run: |
          gem install kamal --no-document
          kamal version
      
      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Verify secret is present
          if [ -z "${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}" ]; then
            echo "❌ Error: PRODUCTION_SSH_PRIVATE_KEY secret is not set"
            echo "Please add this secret in GitHub repository settings"
            exit 1
          fi
          
          echo "✅ PRODUCTION_SSH_PRIVATE_KEY secret is present"
          
          # Write SSH private key (ensure proper newlines)
          echo "${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}" > ~/.ssh/kamal_production_ed25519
          
          # Ensure the key ends with a newline
          echo "" >> ~/.ssh/kamal_production_ed25519
          
          # Set correct permissions
          chmod 600 ~/.ssh/kamal_production_ed25519
          
          # Verify key format
          if ! ssh-keygen -l -f ~/.ssh/kamal_production_ed25519 > /dev/null 2>&1; then
            echo "❌ Error: SSH key is not valid"
            echo "Key fingerprint check failed. Please verify PRODUCTION_SSH_PRIVATE_KEY secret."
            exit 1
          fi
          
          echo "✅ SSH key validated successfully"
          
          # Clear any existing known_hosts to avoid conflicts
          rm -f ~/.ssh/known_hosts
          
          # Add server to known hosts with all key types
          echo "Adding server to known_hosts..."
          ssh-keyscan -H -t rsa,ecdsa,ed25519 146.59.44.70 >> ~/.ssh/known_hosts 2>/dev/null
          
          # Ensure proper permissions
          chmod 644 ~/.ssh/known_hosts
          
          echo "✅ Server fingerprints added to known_hosts"
          echo "Known hosts content:"
          cat ~/.ssh/known_hosts
      
      - name: Configure SSH for Kamal
        run: |
          cat > ~/.ssh/config << 'EOF'
          Host 146.59.44.70
            User ubuntu
            IdentityFile ~/.ssh/kamal_production_ed25519
            StrictHostKeyChecking accept-new
            UserKnownHostsFile ~/.ssh/known_hosts
            IdentitiesOnly yes
          EOF
          chmod 600 ~/.ssh/config
          
          echo "SSH configuration:"
          cat ~/.ssh/config
          
          # Verify known_hosts still exists and has content
          if [ -f ~/.ssh/known_hosts ] && [ -s ~/.ssh/known_hosts ]; then
            echo "✅ known_hosts file exists and has content ($(wc -l < ~/.ssh/known_hosts) lines)"
          else
            echo "❌ Warning: known_hosts file is missing or empty"
            exit 1
          fi
      
      - name: Start SSH agent and add key
        run: |
          # Start SSH agent and capture output
          ssh-agent -s > /tmp/ssh_agent_env
          source /tmp/ssh_agent_env
          
          # Add the SSH key to the agent
          ssh-add ~/.ssh/kamal_production_ed25519
          
          # List loaded keys for verification
          ssh-add -l
          
          # Export SSH_AUTH_SOCK and SSH_AGENT_PID for subsequent steps
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> $GITHUB_ENV
          
          echo "✅ SSH agent started and key added"
          echo "SSH_AUTH_SOCK: $SSH_AUTH_SOCK"
          echo "SSH_AGENT_PID: $SSH_AGENT_PID"
      
      - name: Test SSH connection
        run: |
          echo "Testing SSH connection to production server..."
          if ssh -o ConnectTimeout=10 -o BatchMode=yes ubuntu@146.59.44.70 'echo "✅ SSH connection successful"'; then
            echo "SSH authentication working correctly"
          else
            echo "❌ SSH connection failed"
            echo "Please verify:"
            echo "  1. PRODUCTION_SSH_PRIVATE_KEY secret is set correctly"
            echo "  2. The corresponding public key is in ~/.ssh/authorized_keys on the server"
            echo "  3. The server allows SSH key authentication"
            exit 1
          fi
      
      - name: Login to Docker Hub
        run: |
          echo "${{ env.KAMAL_REGISTRY_PASSWORD }}" | docker login -u "${{ env.KAMAL_REGISTRY_USERNAME }}" --password-stdin
      
      - name: Release deploy lock
        run: kamal lock release -d production || true
      
      - name: Deploy to production
        env:
          SSH_AUTH_SOCK: ${{ env.SSH_AUTH_SOCK }}
        run: |
          # Verify SSH agent is still available
          if [ -z "$SSH_AUTH_SOCK" ]; then
            echo "❌ SSH_AUTH_SOCK not set, SSH agent may have stopped"
            exit 1
          fi
          
          if ! ssh-add -l > /dev/null 2>&1; then
            echo "❌ SSH agent has no keys loaded"
            exit 1
          fi
          
          echo "✅ SSH agent verified with $(ssh-add -l | wc -l) key(s)"
          
          # Run kamal deploy
          kamal deploy -d production
      
      - name: Cleanup old Docker images
        run: kamal prune all -d production || true
        continue-on-error: true